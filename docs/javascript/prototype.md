# JavaScript深入之原型链

### 介绍

JavaScript中的对象有一个特殊的[[prototype]]内置属性，其实就是对于其他对象的引用。几乎所有的对象在创建时[[prototype]]属性都会被赋予一个非空的值。

### prototype属性有什么作用呢

当你试图引用对象的属性时会触发[[Get]]操作，比如obj.a。对于默认的[[get]]操作来说，第一步是检查对象本身是否有这个属性，如果有的话就使用它。但是如果a不在obj中，就需要使用对象的[[Prototype]]链了。

```js
var parentObj = {
    a: 2
}

var obj = Object.create(parentObj)

obj.a // 2
```

如上例：当我们调用obj.a时，很明显obj.a不存在，但是尽管如此，属性仍然访问成功了，并在parentObj中找到了a的值为2。

但是，如果parentObj中也找不到a的话，就会继续查找[[prototype]]链，这个过程会继续到找到匹配的属性名或者查找完整的[[prototype]]链。如果是后者的话，[[Get]]操作的返回值是undefined。

### 原型链的的尽头是什么呢

所有普通的原型链最终都会指向内置的Object.prototype,而Object.prototype的值为null，所以原型链的终点是null。
至于原因呢：

> 首先要明确一点，原型链是指对象的原型链，所以原型链上的所有节点都是对象，不能是字符串、数字、布尔值等原始类型。
另外，规范要求原型链必须是有限长度的(从任一节点出发，经过有限步骤后必须到达一个终点。显然也不能有环。)
那么，应该用什么对象作为终点呢？很显然应该用一个特殊的对象。
好吧，Object.prototype确实是个特殊对象，我们先假设用它做终点。那么考虑一下，当你取它的原型时应该怎么办？即
Object.prototype.__proto__, 应该返回什么？

> 取一个对象的属性时，可能发生三种情况：
1. 如果属性存在，那么返回属性的值。
2. 如果属性不存在，那么返回undefined。
3. 不管属性存在还是不存在，有可能抛异常。

我们已经假设Object.prototype是终点了，所以看起来不能是情况1。

另外，抛出异常也不是好的设计，所以也不是情况3。那么情况2呢，它不存在原型属性，返回undefined怎么样？也不好，因为返回undefined一种解释是原型不存在，但是也相当于原型就是undefined。这样，在原型链上就会存在一个非对象的值。
所以，最佳选择就是null。一方面，你没法访问null的属性，所以起到了终止原型链的作用；另一方面，null在某种意义上也是一种对象，即空对象，因为null一开始就是为表示一个“空”的对象存在的。这样一来，就不会违反“原型链上只能有对象”的约定。
所以，“原型链的终点是null”虽然不是必须不可的，但是却是最合理的。
