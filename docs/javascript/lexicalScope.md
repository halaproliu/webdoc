# JavaScript深入之词法作用域

### 前言

大部分标准语言编译器的第一个工作阶段叫作词法化（也叫单词化）。词法化的过程会对源代码中的字符进行检查，如果是有状态的解析过程，还会赋予单词语义。

这个概念就是理解词法作用域及其名称来历的基础。

简单来说，词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大多数情况下是这样的）。

```js
function foo (a) {   // (1)
    var b = a * 2    // (2)
    function bar (c) { // (3)
        console.log(a, b, c)
    }
    bar(b * 3)
}
foo (2) // 2, 4, 12
```

(1) 包含着整个全局作用域，其中只有一个标识符：foo
(2) 包含着foo所创建的作用域，其中有三个标识符: a、bar和b
(3) 包含着bar所创建的作用域，其中只有一个标识符：c

### 查找变量

在以上的代码片段中，引擎执行console.log(...)声明，并查找a、b和c三个变量的引用。它先从最内部的作用域，也就是bar(...)函数的作用域旗袍开始查找。引擎无法在这里找到a，因此会去上一级到所嵌套的foo(...)的作用域中继续查找。在这里找到了a，因此引擎使用了这个引用。对b来讲也是一样的。而对c来说，引擎在bar(...)中就找到了它。

```作用域查找会正在找到第一个匹配的标识符时停止。```


### 欺骗词法

JavaScript中有两种机制来实现这个目的。分别是eval和with。

eval可以对一段包含一个或多个声明的"代码"字符串进行演算，并借此来修改已经存在的词法作用域（在运行时）。
with本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域。

这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认为这样的优化是无效的。使用这其中任何一个机制都将导致代码运行变慢，最好不要使用它们。
